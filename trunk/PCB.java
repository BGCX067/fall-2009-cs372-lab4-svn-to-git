/*
 * Created on Jan 31, 2004
 *
 * Copyright (c) 2004-09 University of Texas at Austin
 */

/**
 * @author Emmett Witchel, Jungwoo Ha, Ronald L. Rockhold, Cara Kenny,
 *         Pankaj Adhikari
 */
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Properties;
import java.util.Random;

public class PCB {
	Integer pid;
 	private Random rand;
 	// Set to true when we kill a processes that has pending I/O.
 	boolean marked_for_death;
 	private int context_switches = 0;
	private int current_burst;
	private boolean current_burst_exists = false;
	private int executed_ticks = 0;
	private int execution_burst_count = 0;
	private String infile_name;
	boolean is_started = false;
	private String name;
	private int next_trace_index = 0;
	private List past_bursts = new LinkedList();
	private Properties props = new Properties();
	private int quantum = 5;
	private int remaining_burst;
	private int started_time;
	private ArrayList trace = new ArrayList();
    private Object object = null;
    private boolean blocked = false;
	
    public class AppData {
	      public AppData() {
	         mydata = -1;
	      }
	      public byte[] getData(int size) {
	         byte data[] = new byte[size];
	         for (int i=0; i<size; i++)
	        	 data[i] = (byte)mydata;
	         return data;
	      }
	      public void setData(int data) {
	    	  mydata = data;
	      }
	      private int mydata;
	}
	
    private AppData app = new AppData();
    
	PCB(int _pid) {

 		pid = new Integer(_pid);
 		rand = new Random(_pid);
 		marked_for_death = false;
 	}
      
 	PCB(Integer _pid) {

 		pid = new Integer(_pid.intValue());
 		rand = new Random(_pid.intValue());
 		marked_for_death = false;
 	}
 	
 	public void setCurrentBurst(int ticks) {
 		if (ticks<=0) {
 			current_burst_exists = false;
 			return;
 		}
 		current_burst_exists = true;
 		current_burst = ticks;
 		remaining_burst = current_burst;
 	}
 	public int getCurrentBurst() {
 		return current_burst;
 	}
 	
 	public void completed(int current_time) {
 		execution_burst_count++;
 		SchedStats.finishedData(
			this.pid,
			started_time,
			current_time,
			executed_ticks,
			execution_burst_count,
			context_switches);
	}
 	
 	public String toString() {
 		String s = new String();
 		s += pid;
 		if(marked_for_death) {
 			s += " (marked)";
 		}
 		return s;
 	}
      
 	void do_compute(byte[] buffer) {
 		rand.nextBytes(buffer);
 		// page_bytes does not need to be copied back because we wrote
 		// into a reference to an array
 	}
 	
 	public List getBurstHistory() {
		return Collections.unmodifiableList(past_bursts);
	}
 	
	public int getRemainingCPUBurst() {
		if (current_burst_exists) {
			return remaining_burst;
		}
		else return 0;
	}

	public void incrCPUTime(int ticks) {
		if (!current_burst_exists) {
			throw new IllegalStateException("Called with no burst time remaining.");
		}
		if (ticks > remaining_burst) {
			throw new IllegalStateException(
				"ticks "
					+ ticks
					+ " exceeds remaining burst "
					+ remaining_burst);
		}
		executed_ticks += ticks;
		remaining_burst -= ticks;
		if (remaining_burst == 0) {
			past_bursts.add(0, new Integer(current_burst));
			current_burst_exists = false;
		}
	}
	
	public int peekRemainingCPUBurst() {
		if (current_burst_exists) {
			return remaining_burst;
		}
		Integer burst = (Integer) trace.get(next_trace_index);
		current_burst = burst.intValue();
		return current_burst;
	}
	
	public boolean isStarted() {
		return is_started;
	}

	public void started(int current_time) {

		blocked = false;
		started_time = current_time;
		Dbg.println("sc", "Process " + this.pid + " started at time " + current_time);
		is_started = true;
	}

    public void incrDispatches() {
		++context_switches;
    }

    public boolean isBlocked() {
    	return blocked;
    }
    
    public void block() {
    	blocked = true;
    }
    
    public void unblock() {
    	execution_burst_count++;
    	blocked = false;
    }
	/**
	 * IDs are generated by Simulator.  The first process
	 * is id=0, next is 1.
	 * @return This process' id
	 */
	public Integer getPID() {
		return pid;
	}

	/**
	 * The Simulator gives each process a name.  This name
	 * is the same value found in the configuration file for
	 * property "Processes"
	 * @return this process' name
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * Changes the quantum associated with this process.
	 * This change persists until the next setQuantum() call.
	 * When a process is dispatched (IScheduler.schedule()), the
	 * CPU retrieves the quantum from the process.
	 * @param ticks  quantum size
	 */
	public void setQuantum(int ticks) {
		quantum = ticks;
	}
	
	/**
	 * Returns the number of ticks in the current quantum assigned to this process.
	 * Default quantum is 4 ticks.  Use setQuantum(number-of-tics) to change.
	 * When a process is dispatched (IScheduler.schedule()), the
	 * CPU retrieves the quantum from the process.
	 * @return quantum in ticks.
	 */
	public int getQuantum() {
		return quantum;
	}
	
	/**
	 * Associates the object o with this Process.
	 * Since only 1 object can be associated with a Process,
	 * this replaces any previously set Object or the default (null).
	 * @param o
	 */
    public void setObject(Object o) {
        object = o;
    }

    /**
	 * Retrieves the current Object associated with this IProcess.
	 * @return Object, or null.
	 */
    public Object getObject() {
        return object;
    }
    byte[] getAppData(int size) {
        return app.getData(size);
    }

    void setAppData(byte data) {
    	app.setData(data);
  	}
}
